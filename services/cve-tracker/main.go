package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	_ "github.com/lib/pq"
)

const (
	DefaultPort = "8101"
	NVDAPIBase = "https://services.nvd.nist.gov/rest/json/cves/2.0"
	MITREBase = "https://cve.mitre.org/data/downloads"
)

// CVE represents a Common Vulnerabilities and Exposures entry
type CVE struct {
	ID          string    `json:"id"`
	Description string    `json:"description"`
	Severity    string    `json:"severity"`
	CVSS        float64   `json:"cvss_score"`
	Published   time.Time `json:"published"`
	Modified    time.Time `json:"modified"`
	References  []string  `json:"references"`
	Affected    []Product `json:"affected_products"`
	Patches     []Patch   `json:"patches"`
}

// Product represents an affected product
type Product struct {
	Vendor  string `json:"vendor"`
	Product string `json:"product"`
	Version string `json:"version"`
}

// Patch represents available patch information
type Patch struct {
	ID          string    `json:"id"`
	Version     string    `json:"version"`
	URL         string    `json:"url"`
	Description string    `json:"description"`
	Released    time.Time `json:"released"`
}

// ImpactAnalysis represents the impact of CVEs on a specific image
type ImpactAnalysis struct {
	ImageID         string   `json:"image_id"`
	TotalCVEs       int      `json:"total_cves"`
	CriticalCount   int      `json:"critical_count"`
	HighCount       int      `json:"high_count"`
	MediumCount     int      `json:"medium_count"`
	LowCount        int      `json:"low_count"`
	RiskScore       float64  `json:"risk_score"`
	AffectedCVEs    []CVE    `json:"affected_cves"`
	Recommendations []string `json:"recommendations"`
}

// CVETracker manages CVE tracking and analysis
type CVETracker struct {
	db          *sql.DB
	nvdAPIKey   string
	lastUpdate  time.Time
	cacheExpiry time.Duration
}

func NewCVETracker() (*CVETracker, error) {
	// Initialize database connection
	dbURL := os.Getenv("DATABASE_URL")
	if dbURL == "" {
		dbURL = "postgres://postgres:postgres@postgres-postgresql.temporal.svc.cluster.local:5432/cve_tracker?sslmode=disable"
	}

	db, err := sql.Open("postgres", dbURL)
	if err != nil {
		log.Printf("Warning: Database connection failed: %v. Using in-memory cache.", err)
		db = nil
	}

	if db != nil {
		if err := initDatabase(db); err != nil {
			log.Printf("Warning: Failed to initialize database: %v", err)
		}
	}

	return &CVETracker{
		db:          db,
		nvdAPIKey:   os.Getenv("NVD_API_KEY"),
		cacheExpiry: 6 * time.Hour,
	}, nil
}

func initDatabase(db *sql.DB) error {
	schema := `
	CREATE TABLE IF NOT EXISTS cves (
		id VARCHAR(50) PRIMARY KEY,
		description TEXT,
		severity VARCHAR(20),
		cvss_score FLOAT,
		published TIMESTAMP,
		modified TIMESTAMP,
		references TEXT,
		affected_products TEXT,
		patches TEXT,
		created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
	);

	CREATE TABLE IF NOT EXISTS cve_image_mapping (
		id SERIAL PRIMARY KEY,
		cve_id VARCHAR(50),
		image_id VARCHAR(100),
		detected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
		FOREIGN KEY (cve_id) REFERENCES cves(id)
	);

	CREATE INDEX IF NOT EXISTS idx_cves_severity ON cves(severity);
	CREATE INDEX IF NOT EXISTS idx_cves_published ON cves(published);
	CREATE INDEX IF NOT EXISTS idx_mapping_image ON cve_image_mapping(image_id);
	`

	_, err := db.Exec(schema)
	return err
}

func main() {
	port := os.Getenv("PORT")
	if port == "" {
		port = DefaultPort
	}

	tracker, err := NewCVETracker()
	if err != nil {
		log.Fatalf("Failed to initialize CVE tracker: %v", err)
	}

	// Start background CVE feed sync
	go tracker.startFeedSync()

	r := gin.Default()

	// Health check
	r.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"status":      "healthy",
			"service":     "cve-tracker",
			"last_update": tracker.lastUpdate,
		})
	})

	// CVE Management APIs
	r.GET("/cve/search", tracker.searchCVEs)
	r.GET("/cve/latest", tracker.getLatestCVEs)
	r.GET("/cve/:id", tracker.getCVEDetails)
	r.POST("/cve/impact/:image_id", tracker.analyzeImpact)
	r.GET("/cve/patches", tracker.getAvailablePatches)
	r.POST("/cve/sync", tracker.syncCVEFeed)

	// Statistics and Reporting
	r.GET("/stats/summary", tracker.getStatsSummary)
	r.GET("/stats/trends", tracker.getTrends)

	log.Printf("Starting CVE Tracker service on port %s", port)
	if err := r.Run(":" + port); err != nil {
		log.Fatalf("Failed to start server: %v", err)
	}
}

// searchCVEs searches for CVEs based on criteria
func (ct *CVETracker) searchCVEs(c *gin.Context) {
	keyword := c.Query("keyword")
	severity := c.Query("severity")
	product := c.Query("product")
	limit := c.DefaultQuery("limit", "100")

	var cves []CVE

	if ct.db != nil {
		query := `
			SELECT id, description, severity, cvss_score, published, modified
			FROM cves
			WHERE 1=1
		`
		args := []interface{}{}
		argCount := 0

		if keyword != "" {
			argCount++
			query += fmt.Sprintf(" AND (id LIKE $%d OR description LIKE $%d)", argCount, argCount)
			args = append(args, "%"+keyword+"%")
		}

		if severity != "" {
			argCount++
			query += fmt.Sprintf(" AND severity = $%d", argCount)
			args = append(args, severity)
		}

		if product != "" {
			argCount++
			query += fmt.Sprintf(" AND affected_products LIKE $%d", argCount)
			args = append(args, "%"+product+"%")
		}

		query += " ORDER BY published DESC LIMIT " + limit

		rows, err := ct.db.Query(query, args...)
		if err == nil {
			defer rows.Close()
			for rows.Next() {
				var cve CVE

				err := rows.Scan(&cve.ID, &cve.Description, &cve.Severity, 
					&cve.CVSS, &cve.Published, &cve.Modified)
				if err == nil {
					cves = append(cves, cve)
				}
			}
		}
	}

	// If no results from DB, fetch from NVD API
	if len(cves) == 0 {
		cves = ct.fetchFromNVD(keyword, severity)
	}

	c.JSON(http.StatusOK, gin.H{
		"total": len(cves),
		"cves":  cves,
	})
}

// getLatestCVEs returns the most recent CVEs
func (ct *CVETracker) getLatestCVEs(c *gin.Context) {
	hours := c.DefaultQuery("hours", "24")
	
	var cves []CVE

	if ct.db != nil {
		query := `
			SELECT id, description, severity, cvss_score, published, modified
			FROM cves
			WHERE published > NOW() - INTERVAL '%s hours'
			ORDER BY published DESC
			LIMIT 100
		`
		
		rows, err := ct.db.Query(fmt.Sprintf(query, hours))
		if err == nil {
			defer rows.Close()
			for rows.Next() {
				var cve CVE
				err := rows.Scan(&cve.ID, &cve.Description, &cve.Severity,
					&cve.CVSS, &cve.Published, &cve.Modified)
				if err == nil {
					cves = append(cves, cve)
				}
			}
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"period_hours": hours,
		"total":        len(cves),
		"cves":         cves,
	})
}

// getCVEDetails returns detailed information about a specific CVE
func (ct *CVETracker) getCVEDetails(c *gin.Context) {
	cveID := c.Param("id")
	
	var cve CVE

	if ct.db != nil {
		query := `
			SELECT id, description, severity, cvss_score, published, modified,
			       references, affected_products, patches
			FROM cves
			WHERE id = $1
		`
		
		var refsJSON, productsJSON, patchesJSON sql.NullString
		err := ct.db.QueryRow(query, cveID).Scan(
			&cve.ID, &cve.Description, &cve.Severity, &cve.CVSS,
			&cve.Published, &cve.Modified, &refsJSON, &productsJSON, &patchesJSON,
		)

		if err == nil {
			if refsJSON.Valid {
				json.Unmarshal([]byte(refsJSON.String), &cve.References)
			}
			if productsJSON.Valid {
				json.Unmarshal([]byte(productsJSON.String), &cve.Affected)
			}
			if patchesJSON.Valid {
				json.Unmarshal([]byte(patchesJSON.String), &cve.Patches)
			}

			c.JSON(http.StatusOK, cve)
			return
		}
	}

	// If not found in DB, try NVD API
	cve = ct.fetchCVEFromNVD(cveID)
	if cve.ID != "" {
		c.JSON(http.StatusOK, cve)
	} else {
		c.JSON(http.StatusNotFound, gin.H{"error": "CVE not found"})
	}
}

// analyzeImpact analyzes the impact of CVEs on a specific image
func (ct *CVETracker) analyzeImpact(c *gin.Context) {
	imageID := c.Param("image_id")
	
	var requestBody struct {
		Packages []string `json:"packages"`
		Platform string   `json:"platform"`
	}

	if err := c.ShouldBindJSON(&requestBody); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	analysis := ImpactAnalysis{
		ImageID: imageID,
	}

	// Analyze CVEs affecting the image's packages
	for _, pkg := range requestBody.Packages {
		cves := ct.findCVEsForPackage(pkg)
		for _, cve := range cves {
			analysis.AffectedCVEs = append(analysis.AffectedCVEs, cve)
			
			switch strings.ToLower(cve.Severity) {
			case "critical":
				analysis.CriticalCount++
			case "high":
				analysis.HighCount++
			case "medium":
				analysis.MediumCount++
			case "low":
				analysis.LowCount++
			}
		}
	}

	analysis.TotalCVEs = len(analysis.AffectedCVEs)
	
	// Calculate risk score
	analysis.RiskScore = float64(analysis.CriticalCount*10 + 
		analysis.HighCount*5 + 
		analysis.MediumCount*2 + 
		analysis.LowCount*1)

	// Generate recommendations
	if analysis.CriticalCount > 0 {
		analysis.Recommendations = append(analysis.Recommendations,
			"URGENT: Apply patches for critical vulnerabilities immediately")
	}
	if analysis.HighCount > 0 {
		analysis.Recommendations = append(analysis.Recommendations,
			"Schedule patching for high severity vulnerabilities within 7 days")
	}
	if analysis.RiskScore > 50 {
		analysis.Recommendations = append(analysis.Recommendations,
			"Consider rebuilding the image with updated packages")
	}

	c.JSON(http.StatusOK, analysis)
}

// getAvailablePatches returns available patches for vulnerabilities
func (ct *CVETracker) getAvailablePatches(c *gin.Context) {
	// product := c.Query("product") // TODO: implement product filtering
	severity := c.Query("severity")
	
	var patches []Patch

	if ct.db != nil {
		query := `
			SELECT DISTINCT patches
			FROM cves
			WHERE patches IS NOT NULL
		`
		args := []interface{}{}

		if severity != "" {
			query += " AND severity = $1"
			args = append(args, severity)
		}

		rows, err := ct.db.Query(query, args...)
		if err == nil {
			defer rows.Close()
			for rows.Next() {
				var patchesJSON sql.NullString
				if err := rows.Scan(&patchesJSON); err == nil && patchesJSON.Valid {
					var p []Patch
					if err := json.Unmarshal([]byte(patchesJSON.String), &p); err == nil {
						patches = append(patches, p...)
					}
				}
			}
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"total":   len(patches),
		"patches": patches,
	})
}

// syncCVEFeed manually triggers CVE feed synchronization
func (ct *CVETracker) syncCVEFeed(c *gin.Context) {
	go ct.fetchLatestCVEs()
	
	c.JSON(http.StatusAccepted, gin.H{
		"status":  "sync_initiated",
		"message": "CVE feed synchronization started",
	})
}

// getStatsSummary returns CVE statistics summary
func (ct *CVETracker) getStatsSummary(c *gin.Context) {
	stats := map[string]interface{}{
		"last_update": ct.lastUpdate,
	}

	if ct.db != nil {
		// Get total CVEs by severity
		query := `
			SELECT severity, COUNT(*) as count
			FROM cves
			GROUP BY severity
		`
		
		rows, err := ct.db.Query(query)
		if err == nil {
			defer rows.Close()
			severityCounts := map[string]int{}
			for rows.Next() {
				var severity string
				var count int
				if err := rows.Scan(&severity, &count); err == nil {
					severityCounts[severity] = count
				}
			}
			stats["severity_distribution"] = severityCounts
		}

		// Get recent CVE count
		var recentCount int
		ct.db.QueryRow("SELECT COUNT(*) FROM cves WHERE published > NOW() - INTERVAL '7 days'").Scan(&recentCount)
		stats["recent_cves_7d"] = recentCount
	}

	c.JSON(http.StatusOK, stats)
}

// getTrends returns CVE trends over time
func (ct *CVETracker) getTrends(c *gin.Context) {
	days := c.DefaultQuery("days", "30")
	
	trends := []map[string]interface{}{}

	if ct.db != nil {
		query := `
			SELECT DATE(published) as date, severity, COUNT(*) as count
			FROM cves
			WHERE published > NOW() - INTERVAL '%s days'
			GROUP BY DATE(published), severity
			ORDER BY date DESC
		`
		
		rows, err := ct.db.Query(fmt.Sprintf(query, days))
		if err == nil {
			defer rows.Close()
			for rows.Next() {
				var date time.Time
				var severity string
				var count int
				if err := rows.Scan(&date, &severity, &count); err == nil {
					trends = append(trends, map[string]interface{}{
						"date":     date.Format("2006-01-02"),
						"severity": severity,
						"count":    count,
					})
				}
			}
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"period_days": days,
		"trends":      trends,
	})
}

// Background functions

func (ct *CVETracker) startFeedSync() {
	// Initial sync
	ct.fetchLatestCVEs()

	// Schedule periodic sync every 6 hours
	ticker := time.NewTicker(ct.cacheExpiry)
	for range ticker.C {
		ct.fetchLatestCVEs()
	}
}

func (ct *CVETracker) fetchLatestCVEs() {
	log.Println("Fetching latest CVEs from NVD...")
	
	// Fetch from NVD API
	url := NVDAPIBase + "?resultsPerPage=100"
	if ct.nvdAPIKey != "" {
		url += "&apiKey=" + ct.nvdAPIKey
	}

	resp, err := http.Get(url)
	if err != nil {
		log.Printf("Failed to fetch CVEs: %v", err)
		return
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	
	// Parse and store CVEs (simplified)
	var nvdResponse map[string]interface{}
	if err := json.Unmarshal(body, &nvdResponse); err == nil {
		if vulnerabilities, ok := nvdResponse["vulnerabilities"].([]interface{}); ok {
			for _, v := range vulnerabilities {
				// Process and store each CVE
				ct.processCVE(v)
			}
		}
	}

	ct.lastUpdate = time.Now()
	log.Printf("CVE feed sync completed. Last update: %v", ct.lastUpdate)
}

func (ct *CVETracker) processCVE(data interface{}) {
	// Process individual CVE data and store in database
	// This is simplified - real implementation would parse NVD JSON format
}

func (ct *CVETracker) fetchFromNVD(keyword, severity string) []CVE {
	// Fetch CVEs from NVD API based on search criteria
	return []CVE{}
}

func (ct *CVETracker) fetchCVEFromNVD(cveID string) CVE {
	// Fetch specific CVE from NVD API
	return CVE{}
}

func (ct *CVETracker) findCVEsForPackage(pkg string) []CVE {
	// Find CVEs affecting a specific package
	return []CVE{}
}