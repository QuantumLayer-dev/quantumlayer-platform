package activities

import (
	"fmt"
	"strings"
)

// DockerfileTemplate represents a Docker template for a specific language/framework
type DockerfileTemplate struct {
	Language     string
	Framework    string
	BaseImage    string
	BuildStage   string
	RunStage     string
	Port         int
	HealthCheck  string
	StartCommand string
}

// GenerateDockerfile creates an optimized Dockerfile based on the application type
func GenerateDockerfile(language, framework string, dependencies []string, files map[string]string) (string, error) {
	template := getDockerfileTemplate(language, framework)
	
	dockerfile := fmt.Sprintf(`# Multi-stage Dockerfile for %s %s application
# Generated by QuantumLayer Platform

%s

%s

# Health check
%s

# Start the application
%s
`, language, framework, template.BuildStage, template.RunStage, template.HealthCheck, template.StartCommand)

	return dockerfile, nil
}

// getDockerfileTemplate returns the appropriate template for the language/framework combination
func getDockerfileTemplate(language, framework string) DockerfileTemplate {
	switch language {
	case "python":
		return getPythonTemplate(framework)
	case "javascript", "typescript":
		return getNodeTemplate(framework)
	case "go":
		return getGoTemplate(framework)
	case "java":
		return getJavaTemplate(framework)
	default:
		return getGenericTemplate(language)
	}
}

// getPythonTemplate returns Python-specific Docker templates
func getPythonTemplate(framework string) DockerfileTemplate {
	switch strings.ToLower(framework) {
	case "fastapi":
		return DockerfileTemplate{
			Language:  "python",
			Framework: "fastapi",
			BaseImage: "python:3.11-slim",
			Port:      8000,
			BuildStage: `# Build stage
FROM python:3.11-slim as builder

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PYTHONPATH=/app

# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

# Create and set the working directory
WORKDIR /app

# Copy requirements first for better caching
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Production stage
FROM python:3.11-slim as production

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PYTHONPATH=/app

# Install runtime dependencies only
RUN apt-get update && apt-get install -y --no-install-recommends \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/* \
    && useradd --create-home --shell /bin/bash app

WORKDIR /app

# Copy from builder
COPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
COPY --from=builder /usr/local/bin /usr/local/bin
COPY --from=builder /app .

# Change ownership to app user
RUN chown -R app:app /app
USER app

EXPOSE 8000`,
			RunStage: "",
			HealthCheck: `HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1`,
			StartCommand: `CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "4"]`,
		}
	case "django":
		return DockerfileTemplate{
			Language:  "python",
			Framework: "django",
			BaseImage: "python:3.11-slim",
			Port:      8000,
			BuildStage: `# Build stage
FROM python:3.11-slim as builder

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PYTHONPATH=/app

RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

COPY . .
RUN python manage.py collectstatic --noinput

# Production stage
FROM python:3.11-slim as production

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PYTHONPATH=/app

RUN apt-get update && apt-get install -y --no-install-recommends \
    ca-certificates \
    libpq5 \
    && rm -rf /var/lib/apt/lists/* \
    && useradd --create-home --shell /bin/bash app

WORKDIR /app

COPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
COPY --from=builder /usr/local/bin /usr/local/bin
COPY --from=builder /app .

RUN chown -R app:app /app
USER app

EXPOSE 8000`,
			RunStage: "",
			HealthCheck: `HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health/ || exit 1`,
			StartCommand: `CMD ["gunicorn", "--bind", "0.0.0.0:8000", "--workers", "3", "wsgi:application"]`,
		}
	default:
		return DockerfileTemplate{
			Language:  "python",
			Framework: "generic",
			BaseImage: "python:3.11-slim",
			Port:      8000,
			BuildStage: `FROM python:3.11-slim

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

RUN useradd --create-home --shell /bin/bash app

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

COPY . .
RUN chown -R app:app /app
USER app

EXPOSE 8000`,
			RunStage: "",
			HealthCheck: `HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD python -c "import urllib.request; urllib.request.urlopen('http://localhost:8000')" || exit 1`,
			StartCommand: `CMD ["python", "main.py"]`,
		}
	}
}

// getNodeTemplate returns Node.js-specific Docker templates
func getNodeTemplate(framework string) DockerfileTemplate {
	switch strings.ToLower(framework) {
	case "express":
		return DockerfileTemplate{
			Language:  "javascript",
			Framework: "express",
			BaseImage: "node:18-alpine",
			Port:      3000,
			BuildStage: `# Build stage
FROM node:18-alpine as builder

RUN apk add --no-cache dumb-init

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install all dependencies (including dev)
RUN npm ci --only=production && npm cache clean --force

# Copy source code
COPY . .

# Production stage
FROM node:18-alpine as production

RUN apk add --no-cache dumb-init curl && \
    addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001

WORKDIR /app

# Copy from builder
COPY --from=builder --chown=nextjs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nextjs:nodejs /app .

USER nextjs

EXPOSE 3000`,
			RunStage: "",
			HealthCheck: `HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:3000/health || exit 1`,
			StartCommand: `CMD ["dumb-init", "node", "server.js"]`,
		}
	case "nextjs":
		return DockerfileTemplate{
			Language:  "javascript",
			Framework: "nextjs",
			BaseImage: "node:18-alpine",
			Port:      3000,
			BuildStage: `# Dependencies stage
FROM node:18-alpine AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

COPY package.json package-lock.json* ./
RUN npm ci --only=production

# Builder stage
FROM node:18-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

ENV NEXT_TELEMETRY_DISABLED 1
RUN npm run build

# Production stage
FROM node:18-alpine AS production
WORKDIR /app

ENV NODE_ENV production
ENV NEXT_TELEMETRY_DISABLED 1

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000`,
			RunStage: "",
			HealthCheck: `HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:3000/api/health || exit 1`,
			StartCommand: `CMD ["node", "server.js"]`,
		}
	default:
		return DockerfileTemplate{
			Language:  "javascript",
			Framework: "generic",
			BaseImage: "node:18-alpine",
			Port:      3000,
			BuildStage: `FROM node:18-alpine

RUN apk add --no-cache dumb-init curl && \
    addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

COPY . .
RUN chown -R nodejs:nodejs /app
USER nodejs

EXPOSE 3000`,
			RunStage: "",
			HealthCheck: `HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:3000 || exit 1`,
			StartCommand: `CMD ["dumb-init", "node", "index.js"]`,
		}
	}
}

// getGoTemplate returns Go-specific Docker templates
func getGoTemplate(framework string) DockerfileTemplate {
	return DockerfileTemplate{
		Language:  "go",
		Framework: framework,
		BaseImage: "golang:1.21-alpine",
		Port:      8080,
		BuildStage: `# Build stage
FROM golang:1.21-alpine AS builder

RUN apk add --no-cache git ca-certificates tzdata

WORKDIR /build

# Copy go mod files
COPY go.mod go.sum ./
RUN go mod download

# Copy source code
COPY . .

# Build the application
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -ldflags '-extldflags "-static"' -o main .

# Production stage
FROM scratch

# Copy certificates and timezone data
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
COPY --from=builder /usr/share/zoneinfo /usr/share/zoneinfo

# Copy the binary
COPY --from=builder /build/main /app/main

WORKDIR /app

EXPOSE 8080`,
		RunStage: "",
		HealthCheck: `HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD ["/app/main", "--health-check"]`,
		StartCommand: `CMD ["/app/main"]`,
	}
}

// getJavaTemplate returns Java-specific Docker templates
func getJavaTemplate(framework string) DockerfileTemplate {
	return DockerfileTemplate{
		Language:  "java",
		Framework: framework,
		BaseImage: "openjdk:17-jdk-slim",
		Port:      8080,
		BuildStage: `# Build stage
FROM maven:3.8.4-openjdk-17 AS builder

WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline -B

COPY src ./src
RUN mvn clean package -DskipTests

# Production stage
FROM openjdk:17-jre-slim

RUN useradd --create-home --shell /bin/bash app

WORKDIR /app

COPY --from=builder /app/target/*.jar app.jar

RUN chown -R app:app /app
USER app

EXPOSE 8080`,
		RunStage: "",
		HealthCheck: `HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1`,
		StartCommand: `CMD ["java", "-jar", "app.jar"]`,
	}
}

// getGenericTemplate returns a generic template for unknown languages
func getGenericTemplate(language string) DockerfileTemplate {
	return DockerfileTemplate{
		Language:  language,
		Framework: "generic",
		BaseImage: "ubuntu:22.04",
		Port:      8080,
		BuildStage: `FROM ubuntu:22.04

RUN apt-get update && apt-get install -y \
    ca-certificates \
    curl \
    && rm -rf /var/lib/apt/lists/*

RUN useradd --create-home --shell /bin/bash app

WORKDIR /app
COPY . .

RUN chown -R app:app /app
USER app

EXPOSE 8080`,
		RunStage: "",
		HealthCheck: `HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080 || exit 1`,
		StartCommand: `CMD ["./start.sh"]`,
	}
}

// DetectFramework attempts to detect the framework from file contents
func DetectFramework(language string, files map[string]string) string {
	switch language {
	case "python":
		// Check for FastAPI
		for _, content := range files {
			if strings.Contains(content, "from fastapi import") || strings.Contains(content, "import fastapi") {
				return "fastapi"
			}
			if strings.Contains(content, "from django") || strings.Contains(content, "import django") {
				return "django"
			}
			if strings.Contains(content, "from flask import") || strings.Contains(content, "import flask") {
				return "flask"
			}
		}
		// Check requirements.txt
		if requirements, exists := files["requirements.txt"]; exists {
			if strings.Contains(strings.ToLower(requirements), "fastapi") {
				return "fastapi"
			}
			if strings.Contains(strings.ToLower(requirements), "django") {
				return "django"
			}
			if strings.Contains(strings.ToLower(requirements), "flask") {
				return "flask"
			}
		}
	case "javascript", "typescript":
		// Check package.json
		if packageJson, exists := files["package.json"]; exists {
			if strings.Contains(packageJson, `"next"`) {
				return "nextjs"
			}
			if strings.Contains(packageJson, `"express"`) {
				return "express"
			}
			if strings.Contains(packageJson, `"react"`) {
				return "react"
			}
		}
		// Check imports
		for _, content := range files {
			if strings.Contains(content, "import express") || strings.Contains(content, "require('express')") {
				return "express"
			}
			if strings.Contains(content, "from 'next'") || strings.Contains(content, "require('next')") {
				return "nextjs"
			}
		}
	case "go":
		// Check for common Go frameworks
		for _, content := range files {
			if strings.Contains(content, `"github.com/gin-gonic/gin"`) {
				return "gin"
			}
			if strings.Contains(content, `"github.com/gorilla/mux"`) {
				return "gorilla"
			}
			if strings.Contains(content, `"github.com/labstack/echo"`) {
				return "echo"
			}
		}
	case "java":
		// Check for Spring Boot
		for _, content := range files {
			if strings.Contains(content, "@SpringBootApplication") || strings.Contains(content, "spring-boot") {
				return "springboot"
			}
		}
		// Check pom.xml
		if pom, exists := files["pom.xml"]; exists {
			if strings.Contains(pom, "spring-boot-starter") {
				return "springboot"
			}
		}
	}
	
	return "generic"
}